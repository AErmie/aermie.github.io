---
layout: page
title: Book Review: Terraform Cookbook: Efficiently define, launch, and manage Infrastructure as Code across various cloud platforms
date: 2020-10-09 09:18
author: AdinErmie
comments: true
categories: []
---
<a href="/wp-content/uploads/2020/10/Terraform-Cookbook-Book-Cover.png"><img class="alignleft size-medium wp-image-33584" src="/wp-content/uploads/2020/10/Terraform-Cookbook-Book-Cover-242x300.png" alt="" width="242" height="300" /></a>Recently, I finished reading <a href="https://www.amazon.ca/dp/B08H8XD9W4/?coliid=I22EF7JO0BCP41&amp;colid=WU3PPHYI0Z8H&amp;psc=0&amp;ref_=lv_ov_lig_dp_it" target="_blank" rel="noopener noreferrer">Terraform Cookbook: Efficiently define, launch, and manage Infrastructure as Code across various cloud platforms</a> by Mikael Krief.

I am already experienced with Terraform, and have read 3 other Terraform books, along with many other articles, blogs, and videos. Not to mention my own <a href="https://adinermie.com/?s=terraform" target="_blank" rel="noopener noreferrer">blog posts</a> about Terraform, my 3-part video series on "Infrastructure-as-Code (IaC) Using Terraform" available on my <a href="https://www.youtube.com/c/adinermie" target="_blank" rel="noopener noreferrer">YouTube channel</a>, and my own personal curated list of <a href="https://adinermie.com/my-terraform-resources-list-for-those-that-insist-on-being-cloud-agnostic/" target="_blank" rel="noopener noreferrer">Terraform Learning Resources</a> (which I plan to add this book to).

Out of the many books, blogs, articles, etc. I've read, I found this one to be very clear and concise. It is a great resource if you are just getting started with Terraform. It doesn't overload you with a lot of text/material, and has a great format of... Getting Ready, How To Do It, and How It Works.

There isn't one specific chapter that stands out for me, but I appreciated all of the extra links shared for additional information. In Chapter 4 ("<strong>Using the Terraform CLI</strong>"), Chapter 5 ("<strong>Sharing Terraform Configuration with Modules</strong>"), and Chapter 6 ("<strong>Provisioning Azure Infrastructure with Terraform</strong>"), there are some good links to tools that generate Terraform configuration files, and testing frameworks.

<span style="color: #000000;">I’ve decided to share my highlights from reading this specific publication, in case the points that I found of note/interest will be of some benefit to someone else. So, here are my highlights (by chapter). Note that not every chapter will have highlights (depending on the content and the main focus of my work).</span>

If my highlights peak your interest, I strongly recommend that you pick up a copy for yourself.
<h2>Chapter 1: Setting Up the Terraform Environment</h2>
<ul>
 	<li>It is important to know that if your Terraform configuration is in version 0.11, it is not possible to migrate it directly to 0.13. You will first have to upgrade to 0.12 and then migrate to 0.13.</li>
 	<li>It is also recommended by HashiCorp, before performing the migration process, to commit its code in a source code manager (for example, Git) in order to be able to visualize the code changes brought by the migration.</li>
</ul>
<h2>Chapter 2: Writing Terraform Configuration</h2>
<ul>
 	<li>With regard to the specification of the provider version, when executing the <em>terraform init</em> command, if no version is specified, Terraform downloads the latest version of the init provider, otherwise it downloads the specified version</li>
 	<li>It is also important to mention that the version of the Terraform binary that's used is specified in the Terraform state file. This is to ensure that nobody applies this Terraform configuration with a lower version of the Terraform binary, thus ensuring that the format of the Terraform state file conforms with the correct version of the Terraform binary.</li>
 	<li>In addition, with the 0.13 version of Terraform released in August 2020, we can now create custom validation rules for variables which makes it possible for us to verify a value during the <em>terraform plan</em> execution.</li>
 	<li>Note that using the <em>-var </em>option or the <em>TF_VAR_&lt;name of the environment variable&gt;</em> doesn't hardcode these variable's values variable&gt; inside the Terraform configuration. They make it possible for us to give values of variables to the flight. But be careful – these options can have – consequences if the same code is executed with other values initially provided in parameters and the plan's output isn't reviewed carefully.</li>
 	<li>Optionally, we can add a <em>description</em> that describes what the output returns, which can also be very useful for autogenerated documentation or in the use of modules.</li>
 	<li>An article explaining the best practices surrounding Terraform configuration can be found at <a href="https://www.terraform-best-practices.com/code-structure" target="_blank" rel="noopener noreferrer">https://www.terraform-best-practices.com/code-structure</a>.</li>
 	<li>The following blog post explains the folder structure for production Terraform configuration: <a href="https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production" target="_blank" rel="noopener noreferrer">https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production</a></li>
 	<li>The use of data blocks is to be preferred to the use of IDs written in clear text in the code, which can change because the data block recovers the information dynamically.</li>
 	<li>Separating the Terraform configuration is a good practice because it allows better control and maintainability of the Terraform configuration. It also allows us to provision each part separately, without it impacting the rest of the infrastructure.</li>
 	<li>To know when to use a data block or a <em>terraform_remote_state</em> block, the following recommendations must be kept in mind:
<ul>
 	<li>The <em>data</em> block is used in the following cases:
<ul>
 	<li>When external resources have not been provisioned with Terraform configuration (it has been built manually or with a script)</li>
 	<li>When the user providing the resources of our Terraform configuration does not have access to another remote backend</li>
</ul>
</li>
 	<li>The <em>terraform_remote_state</em> block is used in the following cases:
<ul>
 	<li>External resources have not been provisioned with Terraform configuration</li>
 	<li>When the user providing the resources of our Terraform configuration has read access to the other remote backend</li>
 	<li>When the external Terraform state file contains the output of the property we need in our Terraform configuration</li>
</ul>
</li>
</ul>
</li>
 	<li>There is an <em>external</em> resource in Terraform that allows you to call an external program and retrieve its output data so that it can be used in the Terraform
configuration.</li>
 	<li>This <em>external</em> resource contains specifics about the protocol, the format of the parameters, and its output. I advise that you read its documentation to learn more: <a href="https://www.terraform.io/docs/providers/external/data_source.html" target="_blank" rel="noopener noreferrer">https://www.terraform.io/docs/providers/external/data_source.html</a></li>
 	<li>The following are some example articles regarding how to use the Terraform <em>external</em> resource:
<ul>
 	<li><a href="https://dzone.com/articles/lets-play-with-terraform-external-provider" target="_blank" rel="noopener noreferrer">https://dzone.com/articles/lets-play-with-terraform-external-provider</a></li>
 	<li><a href="https://thegrayzone.co.uk/blog/2017/03/external-terraform-provider-powershell/" target="_blank" rel="noopener noreferrer">https://thegrayzone.co.uk/blog/2017/03/external-terraform-provider-powershell/</a></li>
</ul>
</li>
 	<li>In this function, we used the verb to indicate that it is a %s character string that will be replaced, in order, by the name of the application and the name of the environment.</li>
 	<li>It is important to know that the <em>local-exec</em> provisioner, once executed, ensures that the Terraform state file cannot be executed a second time by the <em>terraform apply</em> command.</li>
 	<li>To be able to execute the <em>local-exec</em> command based on a trigger element, such as a resource that has been modified, it is necessary to add a <em>trigger</em> object inside <em>null_resource</em> that will act as the trigger element of the <em>local-exec</em> resource.</li>
 	<li>Please note that the fact a property is sensitive in Terraform means that it cannot be displayed when using the Terraform <em>plan</em> and <em>apply</em> commands in the console output display. On the other hand, it will be present in clear text in the Terraform state file.</li>
</ul>
<h2>Chapter 3: Building Dynamic Environments with Terraform</h2>
<ul>
 	<li>Regarding the <em>lookup</em> and <em>element</em> functions, they can be used, but it is preferable to use the native syntax instead (such as <em>var_name[42]</em> and <em>var_map["key"]</em>) to access elements of a map, list, or set.</li>
</ul>
<h2>Chapter 4: Using the Terraform CLI</h2>
<ul>
 	<li>Among the other options of this command, there is also the <em>-check</em> option, which can be added and allows you to preview the files that will be indented, without applying the changes in the file(s).</li>
 	<li>With the Terraform extension of Visual Studio Code, we can have every Terraform file saved and formatted with the <em>terraform fmt</em> command. For more information, read the pertinent documentation: <a href="https://marketplace.terraform.visualstudio.com/items?itemName=HashiCorp" target="_blank" rel="noopener noreferrer">https://marketplace.terraform.visualstudio.com/items?itemName=HashiCorp</a>.</li>
 	<li>For Git commits, it's possible to automate the execution of the terraform fmt command before each commit by using pre-commits that are hooks to Git: <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" target="_blank" rel="noopener noreferrer">https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks</a>.</li>
 	<li>To use pre-commits with Terraform, refer to this list of hooks provided by Gruntwork: <a href="https://github.com/gruntwork-io/pre-commit" target="_blank" rel="noopener noreferrer">https://github.com/gruntwork-io/pre-commit</a>.</li>
 	<li>If the Terraform configuration contains a <em>backend</em> block, then, for this validation of the configuration, we don't need to connect to this state file. We can add the <em>-backend=false</em> option to the
<em>terraform init</em> command.</li>
 	<li>Finally, if the execution of this Terraform configuration requires variables passed with the <em>-var</em> argument, or with the <em>-var-file</em> option, you cannot use this command. Instead, use <em>terraform plan</em> command, which performs validation during its execution.</li>
 	<li>Since the <em>terraform destroy</em> command deletes all the resources tracked in the Terraform state file, it is important to break the Terraform configuration by separating it into multiple state files to reduce the room for error when changing the infrastructure.</li>
 	<li>If you need to destroy a single resource and not all the resources tracked in the state file, you can add the <em>-target</em> option to the <em>terraform destroy</em> command, which allows you to target the resource to be deleted.</li>
 	<li>Note that the targeting mechanism should only be used as a last resort. In an ideal scenario, the configuration stays in sync with the state file (as applied without any extra <em>target</em> flags). The risk of executing a targeted apply or destroy operation is that other contributors may miss the context and, more importantly, it becomes much more difficult to apply further changes after changing the configuration.</li>
 	<li>Be careful when deleting a workspace that it does not delete the associated resources. That's why, in order to delete a workspace, you must first delete the resources provided by that workspace using the <em>terraform destroy</em> command. Otherwise, if this operation is not carried out, it will no longer be possible to manage these resources with Terraform because the Terraform state file of this workspace will have been deleted.</li>
 	<li>If you are provisioning resources in Azure, there are rather interesting tools that generate the Terraform configuration and the corresponding Terraform state file from Azure resources that have already been created. This open source <strong>Az2Tf</strong> tool is available at <a href="https://github.com/andyt530/py-az2tf" target="_blank" rel="noopener noreferrer">https://github.com/andyt530/py-az2tf</a>. Alternatively, there is <strong>TerraCognita</strong>, which is available at <a href="https://github.com/cycloidio/terracognita/blob/master/README.md" target="_blank" rel="noopener noreferrer">https://github.com/cycloidio/terracognita/blob/master/README.md</a>.</li>
 	<li>Moreover, in order to cancel the taint flag applied with the <em>terraform taint</em> command, we can execute the inverse command.</li>
</ul>
<h2>Chapter 5: Sharing Terraform Configuration with Modules</h2>
<ul>
 	<li>Documentation on the use of the generator is available at <a href="https://docs.microsoft.com/en-us/azure/developer/terraform/create-a-base-template-using-yeoman" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/en-us/azure/developer/terraform/create-a-base-template-using-yeoman</a>.</li>
 	<li>Yeoman documentation is available at <a href="https://yeoman.io/" target="_blank" rel="noopener noreferrer">https://yeoman.io/</a>.</li>
 	<li>Among all of the tools in the Terraform toolbox, there is <em>terraform-docs</em>, an open source, cross-platform tool that allows the documentation of a Terraform module to be generated automatically.</li>
 	<li>We execute <em>terraform-docs</em> specifying in the first argument the type of format of the documentation. In our case, we want it in <em>markdown</em> format. Then, in the second argument, we specify the path of the <em>modules</em> directory.</li>
 	<li>But to go further, we added the <em>&gt; Modules/webapp/Readme.md</em> command, which indicates that the content of the generated documentation will be written in the <em>Readme.md</em> file that will be created in the module directory.</li>
 	<li>In our recipe, we chose to generate markdown documentation, but it is also possible to generate it in JSON, XML, YAML, or text (pretty) format. To do so, you have to add the format option to the <em>terraform-docs</em> command. To know more about the available generation formats, read the documentation here: <a href="https://github.com/terraform-docs/terraform-docs/blob/master/docs/FORMATS_GUIDE.md" target="_blank" rel="noopener noreferrer">https://github.com/terraform-docs/terraform-docs/blob/master/docs/FORMATS_GUIDE.md</a>.</li>
 	<li>The mechanism of the Terrafile pattern is that instead of using the Git sources directly in module calls, we reference them in a file in Terrafile YAML format. In the Terraform configuration, in the module call, we instead use a local path relative to the <em>modules</em> folder.</li>
 	<li>Among the Terraform framework and testing tools is the Terratest framework, created by the Gruntwork community (<a href="https://gruntwork.io/static/" target="_blank" rel="noopener noreferrer">https://gruntwork.io/static/</a>), which is popular and allows testing on code written in the Go language.</li>
 	<li>If Terraform modules provide resources in cloud providers, the authentication parameters must be set before running tests.</li>
 	<li>Read this blog post about Terratest and GitHub Actions, provided by HashiCorp: <a href="https://www.hashicorp.com/blog/continuous-integration-for-terraform-modules-with-github-actions/" target="_blank" rel="noopener noreferrer">https://www.hashicorp.com/blog/continuous-integration-for-terraform-modules-with-github-actions/</a>.</li>
</ul>
<h2>Chapter 6: Provisioning Azure Infrastructure with Terraform</h2>
<ul>
 	<li>A tutorial that shows how to use and configure locally installed Visual Studio Code to execute a Terraform configuration in Azure Cloud Shell: <a href="https://docs.microsoft.com/en-us/azure/developer/terraform/configure-vs-code-extension-for-terraform" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/en-us/azure/developer/terraform/configure-vs-code-extension-for-terraform</a>.</li>
 	<li>This method allows you to provision elements in Azure that are not available in the azurerm provider, but it is important to know that Terraform knows the resources described in this ARM template when it is executed.</li>
 	<li>That is to say that these resources (here, in our resource, it is the extension) do not follow the life cycle of the Terraform workflow and are not registered in the Terraform state file. The only thing that is written in the Terraform state file is the configuration of the resource, azurerm_template_deployment, and, as a consequence, for example, if you run the terraform destroy command on the Terraform configuration, these resources provided by the ARM template will not be destroyed. Instead, only the azurerm_template_deployment resource will be removed from Terraform state file. For this reason, it is advisable that you use this type of deployment only to complete resources that have been provisioned with Terraform HCL code.</li>
 	<li>Documentation pertaining to the <em>when</em> property of <em>provisioner</em> is available here: <a href="https://www.terraform.io/docs/provisioners/index.html#destroy-time-provisioners" target="_blank" rel="noopener noreferrer">https://www.terraform.io/docs/provisioners/index.html#destroy-time-provisioners</a>.</li>
 	<li>If you want to keep a real IaC, it is preferable to use an as-code configuration tool, such as Ansible, Puppet, Chef, or PowerShell DSC.</li>
 	<li><span style="color: #ff0000;">Warning:</span> There can only be one custom script extension per VM. Therefore, you have to put all the configuration operations in a single script.</li>
 	<li>One of the Terraform configuration generation tools, called Terraformer, which is hosted in the GitHub repo of Google Cloud Platform, at <a href="https://github.com/GoogleCloudPlatform/terraformer" target="_blank" rel="noopener noreferrer">https://github.com/GoogleCloudPlatform/terraformer</a>.</li>
 	<li>We generate the Terraform configuration by executing the following Terraformer command:
<ul>
 	<li>terraformer import azure --resources=resource_group --compact --path-pattern {output}/{provider}/</li>
</ul>
</li>
 	<li>Terraformer also contains an option that allows a dry run to preview the code that will be generated. To do this, we will execute the following command that generates a <em>plan.json</em> file, along with a description of the resources that will be generated:
<ul>
 	<li>terraformer plan azure --resources=resource_group --compact --path-pattern {output}/{provider}/</li>
</ul>
</li>
 	<li>We visualize the content of this created JSON file to check its conformity and then, in order to carry out the generation, we execute the following command:
<ul>
 	<li>terraformer import plan generated/azurerm/plan.json</li>
</ul>
</li>
 	<li>Moreover, before using Terraformer, it is necessary to check that the resources to be generated are well supported. For example, in the case of Azure, the list of resources is available here: <a href="https://github.com/GoogleCloudPlatform/terraformer#use-with-azure" target="_blank" rel="noopener noreferrer">https://github.com/GoogleCloudPlatform/terraformer#use-with-azure</a>.</li>
 	<li>Finally, among the other Terraform configuration generation tools, there is a very good tool called <strong>az2tf</strong> (<a href="https://github.com/andyt530/py-az2tf" target="_blank" rel="noopener noreferrer">https://github.com/andyt530/py-az2tf</a>) that used to work on the same Terraformer principle, but unfortunately, this tool is no longer maintained. There is also <strong>TerraCognita</strong> (<a href="https://github.com/cycloidio/terracognita/" target="_blank" rel="noopener noreferrer">https://github.com/cycloidio/terracognita/</a>), which still integrates a number of resources for Azure, and <strong>Terraforming</strong> (<a href="https://github.com/dtan4/terraforming" target="_blank" rel="noopener noreferrer">https://github.com/dtan4/terraforming</a>), which is only operational for AWS.</li>
</ul>
<h2>Chapter 7: Deep Diving into Terraform</h2>
<ul>
 	<li>One of the advantages of Ansible is that it's agentless, which means you don't need to install an agent on the VMs you want to configure. Thus, to know which VMs to configure, Ansible uses a file called inventory, which contains the list of VMs that need configuring.</li>
 	<li>For more details on this templating format, read the documentation at <a href="https://www.terraform.io/docs/configuration/expressions.html#string-templates" target="_blank" rel="noopener noreferrer">https://www.terraform.io/docs/configuration/expressions.html#string-templates</a>.</li>
 	<li>We use the built-in Terraform <em>zipmap</em> function that allows us to build a map from two lists, one being the keys list and the other the values list.</li>
 	<li>Documentation on the <em>zipmap</em> function is available at <a href="https://www.terraform.io/docs/configuration/functions/zipmap.html" target="_blank" rel="noopener noreferrer">https://www.terraform.io/docs/configuration/functions/zipmap.html</a>.</li>
 	<li>Here is a list of web articles that deal with the same subject of Ansible inventories generated by Terraform by proposing different solutions:
<ul>
 	<li><a href="https://hooks.technology/2020/02/using-terraform-and-ansible-together/" target="_blank" rel="noopener noreferrer">https://hooks.technology/2020/02/using-terraform-and-ansible-together/</a></li>
 	<li><a href="https://www.linkbynet.com/produce-an-ansible-inventory-with-terraform" target="_blank" rel="noopener noreferrer">https://www.linkbynet.com/produce-an-ansible-inventory-with-terraform</a></li>
 	<li><a href="https://gist.github.com/hectorcanto/71f732dc02541e265888e924047d47ed" target="_blank" rel="noopener noreferrer">https://gist.github.com/hectorcanto/71f732dc02541e265888e924047d47ed</a></li>
 	<li><a href="https://stackoverflow.com/questions/45489534/best-way-currently-to-create-an-ansible-inventory-from-terraform" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/45489534/best-way-currently-to-create-an-ansible-inventory-from-terraform</a></li>
</ul>
</li>
 	<li>Finally, concerning the writing of the tests, we will use Inspec, which is a test framework based on Rspec. Inspec allows you to test local systems or even infrastructures in the cloud. For more information about Inspec, I suggest you read its documentation at <a href="https://www.inspec.io/" target="_blank" rel="noopener noreferrer">https://www.inspec.io/</a>.</li>
 	<li>To learn more about Inspec profiles, refer to the documentation at <a href="https://www.inspec.io/docs/reference/profiles/" target="_blank" rel="noopener noreferrer">https://www.inspec.io/docs/reference/profiles/</a>.</li>
 	<li>In the case of integration tests in which, after executing the tests, we don't want to destroy the resources that have been built with Terraform, we can execute the <em>kitchen verify</em> command.</li>
 	<li>You can find tutorials on kitchen-terraform at <a href="https://newcontext-oss.github.io/kitchen-terraform/tutorials/" target="_blank" rel="noopener noreferrer">https://newcontext-oss.github.io/kitchen-terraform/tutorials/</a>.</li>
 	<li>For more information about the <em>kitchen test</em> command, see the documentation at <a href="https://kitchen.ci/docs/getting-started/running-test/" target="_blank" rel="noopener noreferrer">https://kitchen.ci/docs/getting-started/running-test/</a>.</li>
 	<li>However, it should be noted that if a resource in the Terraform configuration contains this property, and this property must be deleted when executing the <em>terraform apply</em> command, then this <em>prevent_destroy</em> property prevents the application from making changes to all the resources described in the Terraform configuration. This blocks us from applying changes to resources.</li>
 	<li>An interesting article on the HashiCorp blog about drift management can be found at <a href="https://www.hashicorp.com/blog/detecting-and-managing-drift-with-terraform/" target="_blank" rel="noopener noreferrer">https://www.hashicorp.com/blog/detecting-and-managing-drift-with-terraform/</a>.</li>
 	<li>Read this article from HashiCorp about feature toggles, blue-green deployments, and canary testing using Terraform, available at <a href="https://www.hashicorp.com/blog/terraform-feature-toggles-blue-green-deployments-canary-test/" target="_blank" rel="noopener noreferrer">https://www.hashicorp.com/blog/terraform-feature-toggles-blue-green-deployments-canary-test/</a>.</li>
 	<li>In this block, we added the <em>create_before_destroy</em> property with its value set to true. This property makes the regeneration of a resource possible in the event of destruction by indicating to Terraform to first recreate the resource, and only then to delete the original resource.</li>
 	<li>However, before using <em>create_before_destroy</em>, there are some things to consider, as follows:
<ul>
 	<li>The <em>create_before_destroy</em> property only works when a configuration change requires the deletion and then regeneration of resources. It only works when executing the <em>terraform apply</em> command; it does not work when executing the <em>terraform destroy</em> command.</li>
 	<li>You must be careful that the names of the resources that will be created have different names than the ones that will be destroyed afterward. Otherwise, if the names are identical, the resource may not be created.</li>
</ul>
</li>
 	<li>To implement zero downtime in Azure with Packer and Terraform, read the tutorial at <a href="https://docs.microsoft.com/en-us/azure/developer/terraform/create-vm-scaleset-network-disks-using-packer-hcl" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/en-us/azure/developer/terraform/create-vm-scaleset-network-disks-using-packer-hcl</a>.</li>
 	<li>A good article on zero downtime can be found at <a href="https://dzone.com/articles/zero-downtime-deployment" target="_blank" rel="noopener noreferrer">https://dzone.com/articles/zero-downtime-deployment</a>.</li>
 	<li>There are also other tools for parsing and processing the plan generated by the <em>terraform plan</em> command. Among these tools, there are <em>npm</em> packages such as <em>terraform-plan-parser</em>, available at <a href="https://github.com/lifeomic/terraform-plan-parser" target="_blank" rel="noopener noreferrer">https://github.com/lifeomic/terraform-plan-parser</a>, or <strong>Open Policy Agent for Terraform</strong> at <a href="https://www.openpolicyagent.org/docs/latest/terraform/" target="_blank" rel="noopener noreferrer">https://www.openpolicyagent.org/docs/latest/terraform/</a>.</li>
 	<li>One of the best practices regarding the structure of the configuration is to separate the Terraform configuration into infrastructure and application components, as explained in the article at <a href="https://www.cloudreach.com/en/resources/blog/how-to-simplify-your-terraform-code-structure/" target="_blank" rel="noopener noreferrer">https://www.cloudreach.com/en/resources/blog/how-to-simplify-your-terraform-code-structure/</a>.</li>
 	<li>Externalizing the configuration (which is redundant between each environment) by reading the documentation available at <a href="https://terragrunt.gruntwork.io/docs/features/execute-terraform-commands-on-multiple-modules-at-once/" target="_blank" rel="noopener noreferrer">https://terragrunt.gruntwork.io/docs/features/execute-terraform-commands-on-multiple-modules-at-once/</a>.</li>
 	<li>A useful blog article on the architecture of the Terraform configuration can be found at <a href="https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production/" target="_blank" rel="noopener noreferrer">https://www.hashicorp.com/blog/structuring-hashicorp-terraform-configuration-for-production/</a>.</li>
 	<li>Detailed CLI configuration documentation is available at <a href="https://terragrunt.gruntwork.io/docs/features/keep-your-cli-flags-dry/" target="_blank" rel="noopener noreferrer">https://terragrunt.gruntwork.io/docs/features/keep-your-cli-flags-dry/</a>.</li>
 	<li>Before automating Terraform in any CI/CD pipeline, it is recommended to read HashiCorp's automation guides with recommendations for Terraform. These guides are available here:
<ul>
 	<li><a href="https://learn.hashicorp.com/terraform/development/running-terraform-in-automation" target="_blank" rel="noopener noreferrer">https://learn.hashicorp.com/terraform/development/running-terraform-in-automation</a></li>
 	<li><a href="https://www.terraform.io/docs/cloud/guides/recommended-practices/part3.html" target="_blank" rel="noopener noreferrer">https://www.terraform.io/docs/cloud/guides/recommended-practices/part3.html</a></li>
</ul>
</li>
 	<li>In Terraform's vision, workspaces make it possible to manage several environments by creating several Terraform state files for the same Terraform configuration.</li>
</ul>
<h2>Chapter 8: Using Terraform Cloud to Improve Collaboration</h2>
<ul>
 	<li>If you already have Terraform configurations with state files that are stored in other types of backends and you would like to migrate them to Terraform Cloud, here is the migration documentation: <a href="https://www.terraform.io/docs/cloud/migrate/index.html" target="_blank" rel="noopener noreferrer">https://www.terraform.io/docs/cloud/migrate/index.html</a>.</li>
 	<li>In addition, if your modules have been published in this private registry, you can generate
the Terraform configuration that calls them using the design configuration feature of Terraform Cloud. You can find out more about this at <a href="https://www.terraform.io/docs/cloud/registry/design.html" target="_blank" rel="noopener noreferrer">https://www.terraform.io/docs/cloud/registry/design.html</a>.</li>
 	<li>In order to ensure that the changes are applied in one place, you can't run the <em>terraform apply</em> command on a workspace that is connected to a VCS. However, if your workspace is not connected to a VCS, then you can also execute the <em>apply</em> command from your local CLI.</li>
 	<li>For more information about additional third-party tools in the execution of Terraform Cloud, I recommend reading the documentation available at <a href="https://www.terraform.io/docs/cloud/run/install-software.html" target="_blank" rel="noopener noreferrer">https://www.terraform.io/docs/cloud/run/install-software.html</a>.</li>
 	<li>It is still a good practice to put these policies in a separate repository so that you don't mix the Terraform configuration commits of the policy. Another reason to do this would be that this separate repository could be managed by another team (such as ops or security).</li>
 	<li>As far as blocking the application is concerned, this is configured in the <em>sentinel.hcl</em> file with the <em>enforcement_level ="hard-mandatory"</em> property for each policy. To find out more about the values of this property and their implication, read the documentation at <a href="https://docs.hashicorp.com/sentinel/concepts/enforcement-levels/" target="_blank" rel="noopener noreferrer">https://docs.hashicorp.com/sentinel/concepts/enforcement-levels/</a> and here <a href="https://www.terraform.io/docs/cloud/sentinel/manage-policies.html" target="_blank" rel="noopener noreferrer">https://www.terraform.io/docs/cloud/sentinel/manage-policies.html</a>.</li>
 	<li>The guide to writing and installing policies is available here: <a href="https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform/" target="_blank" rel="noopener noreferrer">https://www.hashicorp.com/resources/writing-and-testing-sentinel-policies-for-terraform/</a>.</li>
 	<li>The basic learning guide for policies is available here: <a href="https://learn.hashicorp.com/terraform/cloud-getting-started/enforce-policies" target="_blank" rel="noopener noreferrer">https://learn.hashicorp.com/terraform/cloud-getting-started/enforce-policies</a>.</li>
 	<li>There are other tools we can use to write and execute Terraform compliance configuration, such as terraform-compliance (<a href="https://github.com/eerkunt/terraform-compliance" target="_blank" rel="noopener noreferrer">https://github.com/eerkunt/terraform-compliance</a>) and Open Policy Agent (<a href="https://www.openpolicyagent.org/docs/latest/terraform/" target="_blank" rel="noopener noreferrer">https://www.openpolicyagent.org/docs/latest/terraform/</a>). They are both free and open source, but beware: they can't be used in a Terraform Cloud execution.</li>
 	<li>You can also write policies with Sentinel (which we studied in the previous recipe) to integrate compliance rules for estimated costs. For more information, please read the documentation at <a href="https://www.terraform.io/docs/cloud/cost-estimation/index.html#verifying-costs-in-policies" target="_blank" rel="noopener noreferrer">https://www.terraform.io/docs/cloud/cost-estimation/index.html#verifying-costs-in-policies</a>.</li>
</ul>
