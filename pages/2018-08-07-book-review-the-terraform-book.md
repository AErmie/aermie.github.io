---
layout: page
title: Book Review: The Terraform Book
date: 2018-08-07 17:02
author: AdinErmie
comments: true
categories: []
---
<!-- wp:image {"id":31398,"align":"left","width":225,"height":360,"linkDestination":"media"} -->
<figure class="wp-block-image alignleft is-resized"><a href="/wp-content/uploads/2018/08/TheTerraformBook_Cover.jpg"><img src="/wp-content/uploads/2018/08/TheTerraformBook_Cover.jpg" alt="" class="wp-image-31398" width="225" height="360"/></a></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Recently, I finished reading <a href="https://terraformbook.com/" target="_blank">The Terraform Book</a> by James Turnbull.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When I started reading this book, I had very little (but at least some) experience with Terraform. And so, I was looking for a book that would provide a good foundation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I particularly found chapter 2 <strong>("Installing Terraform”)</strong> and chapter 3 <strong>("Building Our First Application")</strong> of great value, because it built on what little I already <g class="gr_ gr_80 gr-alert sel gr_spell gr_replaced gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del" id="80" data-gr-id="80">knew</g>, and gave me not only a good foundation to start with, but also a real-world type of an example in building an application's infrastructure through code. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The only thing I wish this book (or similar resources <g class="gr_ gr_44 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="44" data-gr-id="44">like</g> it) had, was examples specific to Microsoft Azure (since that's the environment I'm working in). Most Terraform tutorials, books, videos, courses, etc. all seem to focus on Amazon Web Services (AWS). </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I’ve decided to share my highlights from reading this specific publication, in case the points that I found of note/interest will be of some benefit to someone else. So, here are my highlights (by chapter). Note that not every chapter will have highlights (depending on the content and the main focus of my work).</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Chapter 1: An Introduction to Terraform</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>None (just and introduction)</li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Chapter 2: Installing Terraform</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>When Terraform runs inside a directory it will load any Terraform configuration files. Any non-configuration files are ignored and Terraform will not recurse into any sub-directories. Each file is loaded in alphabetical order, and the contents of each configuration file are appended into one configuration.</li><li>The configuration loading model allows us to treat individual directories, like base, as standalone configurations or environments.</li><li>Each directory could represent an environment, stack, or application in our organization.</li><li>Terraform configuration files are normal text files. They are suffixed with either .tf or .tf.json. Files suffixed with .tf are in Terraform’s native file format, and .tf.json files are <a href="https://en.wikipedia.org/wiki/JSON" target="_blank">JSON</a>-formatted.</li><li>The two configuration file formats are for two different types of audiences:<ul><li>Humans</li><li>Machines</li></ul></li><li>The .tf format, also called the <a href="https://github.com/hashicorp/hcl" target="_blank">HashiCorp Configuration Language</a> or <g class="gr_ gr_237 gr-alert gr_gramm gr_inline_cards gr_run_anim Punctuation only-del replaceWithoutSep" id="237" data-gr-id="237">HCL,</g> is broadly human-readable, allows inline comments, and is generally recommended if humans are crafting your configuration.<br/></li><li>TIP You can specify a mix of the Terraform file formats in a directory.</li><li>Providers are not shipped with Terraform since Terraform 0.10. In order to download the providers you’re using in your environment you need to run the terraform init command to install any required providers. <br/></li><li>TIP Instead of hard-coding the AWS credentials you can also use <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-environment" target="_blank">environment variables</a> or <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html#cli-config-files" target="_blank">AWS shared credentials</a>.</li><li>The name of the resource is specified next. This name is defined by you—here we’ve named this resource base. The name of the resource should generally describe what the resource is or does.</li><li>NOTE Your configuration is defined as the scope of what configuration<br/>Terraform loads when it runs. You can have a resource with a duplicate name in another configuration—for example, another directory of Terraform files.</li><li>NOTE Remember Terraform commands load all the Terraform configuration in the current directory.</li><li>There are a series of similar indicators:<ul><li>+: A resource that will be added.</li><li>-: A resource that will be destroyed.</li><li>-/+: A resource that will be destroyed and then added again.</li><li>~: A resource will be changed.</li></ul></li><li>A value is one that Terraform does not know the value of yet. The value of the configuration item will only be known when the resource<br/>is actually created. </li><li>TIP Since <a href="https://www.terraform.io/upgrade-guides/0-11.html#interactive-approval-in-terraform-apply" target="_blank">Terraform 0.11</a> the terraform apply command now prompts interactively like the terraform plan command. You can override this behavior with the -auto-approve flag.</li><li>After creating our resource, Terraform has saved the current state of our infrastructure into a file called terraform.tfstate in our base directory. This is called a state file. The state file contains a map of resources and their data to resource IDs.</li><li>The state is the canonical record of what Terraform is managing for you. This file is important because it is canonical. If you delete the file Terraform will not know what resources you are managing, and it will attempt to apply all configuration from scratch. This is bad. You should ensure you preserve this file.</li><li>Some Terraform documentation recommends putting this file into version control. We do not. The state file contains everything in your configuration, including any secrets you might have defined in them. We recommend instead adding this file to <a href="https://git-scm.com/docs/gitignore" target="_blank">your .gitignore configuration</a>.</li><li>As this file is the source of truth for the infrastructure being managed, it’s critical to only use Terraform to manage that infrastructure. If you make a change to your infrastructure manually, or if you use another tool, it can be easy for this state to get out of sync with reality. You can then lose track of the state of your infrastructure and its configuration, or have Terraform reset your infrastructure back to a potentially non-functioning configuration when it runs.</li><li>TIP Have existing infrastructure? Terraform can import it. You can read about how in the <a href="https://www.terraform.io/docs/import/index.html" target="_blank">Terraform import documentation</a>. In some cases, it’s also possible to recreate an accidentally deleted state file by importing resources.</li><li>Attribute references are variables and are very useful. They allow us to use values from one resource in another resource.</li><li>Two useful commands we might run before planning our configuration <g class="gr_ gr_219 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="219" data-gr-id="219">are terraform</g> validate and terraform <g class="gr_ gr_167 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling" id="167" data-gr-id="167">fmt</g>. The validate command checks the syntax and validates your Terraform configuration files and returns any errors. The <g class="gr_ gr_168 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling" id="168" data-gr-id="168">fmt</g> command neatly formats your configuration files.</li><li>You could even specify both as a <a href="https://githooks.com/" target="_blank">pre-commit hook</a> in your Git repository. There’s an example of a hook like this in <a href="https://gist.github.com/jamtur01/a567078b7ba545c3492f7cd32a65450d" target="_blank">this gist</a>.</li><li>Every Terraform plan or apply follows the same process:<ul><li>We query the state of the <g class="gr_ gr_234 gr-alert gr_gramm gr_inline_cards gr_run_anim Punctuation only-del replaceWithoutSep" id="234" data-gr-id="234">resources,</g> if they exist now.<br/></li><li>We compare that state against any proposed changes to be made, building the graph of resources and their relationships. As a result of the graph, Terraform will only propose the set of required changes.<br/></li><li>If they are not the same, either show the proposed change, if in the <g class="gr_ gr_172 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="172" data-gr-id="172">plan</g> <g class="gr_ gr_173 gr-alert gr_gramm gr_inline_cards gr_run_anim Punctuation only-del replaceWithoutSep" id="173" data-gr-id="173">phase,</g> or make the change, if in the <g class="gr_ gr_174 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling" id="174" data-gr-id="174">apply</g> phase.<br/></li></ul></li><li>If any other changes had been made to our infrastructure, outside of Terraform, then Terraform would also show us what would be needed to bring the infrastructure back in line with our Terraform configuration.</li><li>Where possible, Terraform will aim to perform the smallest incremental change rather than rebuilding every resource. In some cases, however, changing a resource requires recreating it. Since this is a destructive action, you should always carefully read the proposed actions in a terraform apply before saying yes or run terraform plan first to understand the impact of executing the change.</li><li>Terraform has an approach for trying to limit the risk of large-scale destructive changes to our environment and allowing us to make increment changes. To do this Terraform captures the proposed changes by outputting the plan it intends <g class="gr_ gr_194 gr-alert gr_gramm gr_inline_cards gr_run_anim Style multiReplace" id="194" data-gr-id="194">to  run</g> to a file.<br/></li><li>Terraform calls this a <g class="gr_ gr_224 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="224" data-gr-id="224">plan</g> output. We capture the plan by specifying the -out flag on a terraform plan command. This will capture the proposed changes in a file we specify. The plan output means we can make small, incremental changes to our infrastructure.</li><li>So this looks like we made the same change as if we’d run terraform apply alone. Why is this useful? First, we don’t have to apply this change immediately. The plan output can be kept and stored as a potential incremental change. </li><li>This is also the way we’d typically run automated Terraform actions, for example in a script or continuous integration tool. This avoids <g class="gr_ gr_185 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="185" data-gr-id="185">terraform</g> apply’s interactive mode because obviously in most scripts you can’t answer yes.</li><li>WARNING The generated plan file will contain all your variable values, potentially including any credentials or secrets. It is not encrypted or otherwise protected. Handle this file with appropriate caution! </li><li>To help with the systematic and incremental rollout of resources, Terraform has another useful flag: -target. You can use the -target flag on both the terraform plan and terraform apply commands. It allows you to target a resource—or more if you specify multiple -target flags—to be managed in an execution plan. </li><li>If our execution plan had failed, then Terraform would not roll back the resources. It’ll instead mark the failed resource as <a href="https://www.terraform.io/docs/commands/taint.html" target="_blank">tainted</a>. The tainted state is Terraform’s way of saying, “This resource may not be right.” Why tainting instead of rolling back? Terraform always holds to the execution plan: it was asked to create a resource, not delete one. If you run the execution plan again, Terraform will attempt to destroy and recreate any tainted resources.</li><li>Terraform configurations do not depend on the order in which they are defined. </li><li>Terraform is a <a href="https://en.wikipedia.org/wiki/Declarative_programming" target="_blank">declarative system</a>; you specify the proposed state of your resources rather than the steps needed to create those resources. When you specify resources, Terraform builds a <a href="https://en.wikipedia.org/wiki/Dependency_graph" target="_blank">dependency graph</a> of your configuration. The dependency graph represents the relationships between the resources in your configuration. When you plan or apply that configuration, Terraform walks that graph, works out which resources are related, and hence knows the order in which to apply them. </li><li>TIP As a result of the dependency graph, Terraform tries to perform as many operations in parallel as it can. It can do this because it knows what it has to sequence and what it can create stand-alone. </li><li>NOTE Generally you always want the graph to dictate resource ordering. But sometimes we do need to force order in our resources. If we need to do this we can use a special attribute called <a href="https://www.terraform.io/docs/configuration/resources.html#depends_on" target="_blank">depends_on</a>. </li><li>The graph command outputs our dependency graph in <a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)" target="_blank">the DOT graph format</a>. That output can be piped to a file so we can visualize the graph. We can then view this graph in an application like <a href="http://www.graphviz.org/" target="_blank">Graphviz</a>. If you don’t want to install Graphviz then you can use the online <a href="http://webgraphviz.com/" target="_blank" rel="noopener">WebGraphviz</a> tool. </li><li>The terraform destroy command, without any options, destroys everything! </li><li>WARNING If the above paragraph isn’t already sending warning signals… be very, very careful with <g class="gr_ gr_203 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="203" data-gr-id="203">terraform</g> destroy. You can easily destroy your entire infrastructure. </li><li>If you only want to destroy a specific resource then you can use the -target flag. </li><li>The -target flag will also destroy any dependencies of the resource specified. </li><li>You can also plan the terraform destroy process by passing the -destroy flag to the terraform plan command and saving a plan file.</li><li>TIP Terraform also has the concept of <a href="https://www.terraform.io/docs/commands/taint.html" target="_blank">tainting</a> and <a href="https://www.terraform.io/docs/commands/untaint.html" target="_blank">untainting</a> resources. Tainting resources marks a single resource to be destroyed and recreated on the next <g class="gr_ gr_230 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling" id="230" data-gr-id="230">apply</g>. It doesn’t change the resource but rather the current state of the resource. Untainting reverses the marking.<br/></li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Chapter 3: Building Our First Application</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank">DRY</a> is an abbreviation for “Don’t Repeat Yourself,” a software principle that recommends reducing the repetition of information. </li><li>We start by creating a file, called variables.tf, to hold our variables. We create the file in the ~/<g class="gr_ gr_201 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="201" data-gr-id="201">terraform</g>/base directory.</li><li>TIP The file can be called anything. We’ve just named it variables.tf for<br/>convenience and identification. Remember all files that end in .tf will be loaded by Terraform.</li><li>Terraform variables are created with a variable block. They have a name and an optional type, default, and description.</li><li>If you omit the type attribute then Terraform assumes your variable is a <g class="gr_ gr_180 gr-alert gr_gramm gr_inline_cards gr_run_anim Punctuation only-del replaceWithoutSep" id="180" data-gr-id="180">string,</g> unless the default is in the format of another variable type. </li><li>TIP We recommend you always add variable descriptions. You never know who’ll be using your code, and it’ll make their (and your) life a lot easier if every variable has a clear description. Comments are fun too. </li><li>Each variable is identified as a variable by the var. prefix.</li><li>TIP Since Terraform 0.8 there is a command called terraform console. The console is a Terraform REPL that allows you to work with interpolations and other logic. It’s a good way to explore working with Terraform syntax. You can read about it in the <a href="https://www.terraform.io/docs/commands/console.html" target="_blank">console command documentation</a>.</li><li>NOTE We don’t need to specify the variable type if the variable’s default is in the form of a map. In that <g class="gr_ gr_237 gr-alert gr_gramm gr_inline_cards gr_run_anim Punctuation only-ins replaceWithoutSep" id="237" data-gr-id="237">case</g> Terraform will automatically assume you’ve defined a map. </li><li>Terraform has a set of built-in functions to make it easier to work with variables and values.</li><li>NOTE You can find a full list of functions in <a href="https://www.terraform.io/docs/configuration/interpolation.html" target="_blank">the Terraform documentation</a>.</li><li>NOTE You can also use the element function to retrieve a value from a<br/>list.</li><li>Variables with and without defaults behave differently. A defined, but empty, variable is a required value for an execution plan.</li><li>Terraform has a variety of methods by which you can populate variables. Those ways, in order of descending resolution, are:<ul><li>Loading variables from command line flags.</li><li>Loading variables from a file.</li><li>Loading variables from environment variables.</li><li>Variable defaults.</li></ul></li><li>When Terraform runs it will look for a file called terraform.tfvars. We can populate this file with variable values that will be loaded when Terraform runs. </li><li>You can also name the terraform<g class="gr_ gr_218 gr-alert gr_gramm gr_inline_cards gr_run_anim Style replaceWithoutSep" id="218" data-gr-id="218">.<g class="gr_ gr_176 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="176" data-gr-id="176">tfvars</g></g> file something else—for example, we could have a variable file named base.tfvars. If you do specify a new file name, you will need to tell Terraform where the file is with the -var-file command line flag.</li><li>TIP You can use more than one -<g class="gr_ gr_227 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar only-ins doubleReplace replaceWithoutSep" id="227" data-gr-id="227">var-file</g> flag to specify more than one file. If you specify more than one file, the files are evaluated from first to last, in the order specified on the command line. If a variable value is specified multiple times, the last value defined is used.</li><li>TIP Variable files and environment variables are a good way of protecting passwords and secrets. This avoids storing them in our configuration files, where they might end up in version control. A better way is obviously some sort of secrets store. Since Terraform 0.8 there is now support for <a href="https://www.terraform.io/docs/providers/vault/index.html" target="_blank">integration with Vault for secrets management</a>. </li><li>Variable defaults are specified with the default attribute. If nothing in the above list of variable population methods resolves the variable then Terraform will use the default.</li><li>TIP Terraform also has an “override” file construct. When Terraform loads configuration files it appends them. With <a href="https://www.terraform.io/docs/configuration/override.html" target="_blank">an override the files are instead merged</a>. This allows you to override resources and variables. </li><li>Terraform configurations in individual directories are isolated. Our new configuration in the web directory will, by default, not be able to refer to, or indeed know about, any of the <g class="gr_ gr_198 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="198" data-gr-id="198">configuration</g> in the base directory. </li><li><a href="https://www.terraform.io/docs/modules/index.html" target="_blank">Modules</a> are defined with the module block. Modules are a way of constructing reusable bundles of resources. They allow you to organize collections of Terraform code that you can share across configurations. </li><li>You can configure inputs and outputs for modules: an API interface to your modules. This allows you to customize them for specific requirements, while your code remains as DRY and reusable as possible.</li><li>TIP Hashicorp makes available a collection of verified and community modules in the <a href="https://registry.terraform.io/" target="_blank">Terraform Module Registry</a>. These include modules for a large number of purposes and are a good point to start if you need a module. You can learn more about the Terraform Module Registry in <a href="https://www.terraform.io/docs/registry/index.html" target="_blank">the documentation</a>. </li><li>To Terraform, every directory containing configuration is automatically a module. Using modules just means referencing that configuration explicitly. References to modules are created with the module block. </li><li>Modules look just like resources only without a type. Each module requires a name. The module name must be unique in the configuration. </li><li>Modules only have one required attribute: the module’s source. The source tells Terraform where to find the module’s source code.</li><li>TIP This path manipulation in Terraform is often tricky. To help with this, Terraform provides a built-in variable called path. You can read about how to use the path variable in <a href="https://www.terraform.io/docs/configuration/interpolation.html#path-variables" target="_blank">the interpolation path variable documentation</a>.</li><li>The namespace is like an organization or source of the module. The name is the module’s name and the provider is the specific provider it uses. The <a href="https://registry.terraform.io/modules/terraform-aws-modules/vpc/aws/1.37.0" target="_blank">module’s homepage</a> will contain full documentation on how to use it, including any required inputs and any outputs.</li><li>NOTE Modules with a blue tick on the Terraform Registry are <a href="https://www.terraform.io/docs/registry/modules/verified.html" target="_blank">verified</a> and from a Hashicorp partner. These modules should be more resilient and tested than others. You can also <a href="https://www.terraform.io/docs/registry/modules/publish.html" target="_blank">publish</a> your own modules on the Registry.</li><li>TIP You can read more about module provider inheritance in the <a href="https://www.terraform.io/docs/modules/usage.html#providers-within-modules" target="_blank">modules documentation</a>.</li><li>The <a href="https://www.terraform.io/docs/configuration/outputs.html" target="_blank">output construct</a> can be used in any Terraform configuration, not just in modules. It is a way to highlight specific information from the attributes of resources we’re creating. This allows us to selectively return critical information to the user or to another application rather than returning all the possible attributes of all resources and having to filter the information down. </li><li>You can see that, like a variable, an output is configured as a block with a name. Each output has a value, usually an interpolated attribute from a resource being configured.</li><li>TIP Since Terraform 0.8, you can also add a description attribute to your outputs, much like you can for your variables. </li><li>Outputs can also be marked as containing sensitive material by setting the sensitive attribute. </li><li>When outputs are displayed—for instance, at the end of the application of a plan—sensitive outputs are redacted, with displayed instead of their value. </li><li>NOTE This is purely a visual change. The outputs are not encrypted or<br/>protected.</li><li>NOTE We recommend using a naming convention for Terraform files inside modules. This isn’t required but it makes code organization and comprehension easier.</li><li>TIP Since Terraform 0.8, you can also specify the depends_on meta-parameter to explicitly create a dependency on a module. You can reference a module via name, for <g class="gr_ gr_188 gr-alert gr_gramm gr_inline_cards gr_run_anim Punctuation only-ins replaceWithoutSep" id="188" data-gr-id="188">example</g> module.vpc.</li><li>TIP The fine folks at Segment.io have released an excellent tool called<br/>terraform-docs. The <a href="https://github.com/segmentio/terraform-docs" target="_blank">terraform-docs</a> tool reads modules and produces Markdown or JSON documentation for the module based on its variables and outputs.</li><li>Sometimes we want to refer to the set of resources created via a count. To do this Terraform has a splat syntax: *. This allows us to refer to all of these resources in a variable. </li><li>The format function formats strings according to a specified format. </li><li>The format function is essentially a <g class="gr_ gr_174 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="174" data-gr-id="174">sprintf</g> and is a wrapper around <a href="https://golang.org/pkg/fmt/" target="_blank">Go’s fmt library syntax</a>. So %03d is constructed from 0, indicating that you want to pad the number to the specified width with leading zeros. Then 3 indicates the width that you want, and d specifies a base 10 integer. The flags together will pad single digits with a leading 0 but ignore numbers larger than three digits in length. </li><li>We can, however, cause Terraform to wrap the list using <a href="https://www.terraform.io/docs/configuration/interpolation.html#element_list_index_" target="_blank">the element function</a>. The element function pulls an element from a list using the given index and wraps when it reaches the end of the list.</li><li>The condition can be any interpolation: a variable, a function, or even chaining another conditional. The true or false values can also return any interpolation or <g class="gr_ gr_213 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar only-ins doubleReplace replaceWithoutSep" id="213" data-gr-id="213">valid</g> value. The true and false values must return the same type though.</li><li>TIP You can read more about conditionals in <a href="https://www.terraform.io/docs/configuration/interpolation.html#conditionals" target="_blank">their documentation</a>.</li><li>Terraform also has the concept of local value configuration. Local values assign a name to an expression, essentially allowing you to create repeatable function-like values. </li><li>TIP A local is only available in the context of the module it is defined in. It will not work cross-module. </li><li>You can specify one or many locals blocks in a module. We’d recommend grouping them together for maintainability. If you use more than one <g class="gr_ gr_208 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="208" data-gr-id="208">locals</g> block in a module then the names of the locals defined must be unique across the module.</li><li>If we want to see these outputs again, rather than applying the configuration again, we can run the terraform output command.</li><li>TIP Remember if you want to see the full list of all our resources and their attributes you can run the terraform show command. </li><li>TIP In addition to building a stack from your configuration, you can do the reverse and import existing infrastructure. You can read more about the <a href="https://www.terraform.io/docs/state/import.html" target="_blank">import process in the Terraform documentation</a>.<br/></li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Chapter 4: Provisioning and Terraform</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>Terraform isn’t designed to replace your configuration management tool—rather, it’s made to integrate with it. Terraform’s sweet spot is the management of your infrastructure components. </li><li>TIP Terraform is not a configuration management tool. Really, it isn’t. Use it to set up your configuration management tool; do not use it to build your hosts. </li><li>The most important piece of information here is that provisioners only run when a resource is created or destroyed. They do not run when a resource is changed or updated. This means that if you want to trigger provisioning again, you will need to destroy and recreate the resource, which is often not convenient or practical. Again, Terraform’s provisioning is not a replacement for configuration management. </li><li>NOTE To provision you’ll need to be able to make an appropriate WinRM or SSH connection from the machine running Terraform to the resource being provisioned.  </li><li>TIP Another approach is to bake your provisioning or configuration management tool into your <g class="gr_ gr_171 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del" id="171" data-gr-id="171">compute</g> images— for example, by using a tool like <a href="https://www.packer.io/" target="_blank">Packer</a> to create virtual machine images or AMIs. This reduces the requirement to do provisioning with Terraform.</li><li>You can find a full list of connection options in the <a href="https://www.terraform.io/docs/provisioners/connection.html" target="_blank" rel="noopener">connection block documentation</a>.</li><li>Data sources provide read-only data that can be used in your configuration. Data sources are linked to providers. Not every provider has data sources—<g class="gr_ gr_245 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Punctuation only-ins replaceWithoutSep" id="245" data-gr-id="245">generally</g> they exist if there are sources of information that are useful in the configuration managed by the provider. </li><li>TIP The template provider only has two resources: template_file, which creates template files, and template_cloudinit_config, which allows you to template cloud-init configurations.  </li><li>TIP The file provisioner uses the permissions of the user we connect to the instance with. For us, this is the <g class="gr_ gr_305 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="305" data-gr-id="305">ubuntu</g> user we specified in the connection block. This user must have permission to write to the chosen destination. If it does not have permission, the provisioner will fail. </li><li>TIP Another useful place for the template_file data source is as the value of the user_data attribute. We can render a template file that will be executed to provision our hosts, along with any variables we might find useful. </li><li>You can only use <g class="gr_ gr_390 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling multiReplace" id="390" data-gr-id="390">self variables</g> in provisioners. They do not work anywhere else.</li><li>The file provisioner loosely follows the rules of the <g class="gr_ gr_400 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="400" data-gr-id="400">rsync</g> tool and uses the presence or absence of a trailing / to determine its upload behavior. </li><li>If the source directory has a trailing /, the contents of the directory will be uploaded into the destination directory. So a source of files/ will upload the contents of the files directory to the destination.</li><li>If the source directory doesn’t have a trailing /, a new directory will be created inside the destination directory. So a source of files will upload the files directory to the destination, creating, for example, /root/files. </li><li><a href="https://www.terraform.io/docs/provisioners/remote-exec.html" target="_blank">The remote-exec provisioner</a> runs scripts or commands on a remote instance. It can run in three modes:<ul><li>Run a single script.</li><li>Run a list of scripts in the order specified.</li><li>Run a list of commands in the order specified.</li></ul></li><li>TIP The remote-exec provisioner has a counterpart: local-exec. The<br/>local-exec provisioner runs commands locally on the host running Terraform. You can read about the local-exec provisioner <a href="https://www.terraform.io/docs/provisioners/local-exec.html" target="_blank" rel="noopener">in its provisioner documentation</a>. </li><li>There is one shortcoming with both the single- and multiple-script execution modes: you can’t pass any arguments to the scripts being run. </li><li>If you do want to run a script with an argument, there’s a workaround available. We use the file provisioner to first upload the script and then run it with remote -exec in its final mode, running inline commands. </li><li>TIP There is a workaround for decoupling the destroy/recreate life cycle for provisioning. It involves using the null_resource provisioner, which allows you to <a href="https://www.terraform.io/docs/provisioners/null_resource.html" target="_blank">create centralized provisioning configuration</a> tied to triggers. <br/></li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Chapter 5: Collaborating with Terraform</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>TIP Terraform has another command that can be useful here: refresh. The <a href="https://www.terraform.io/docs/commands/refresh.html" target="_blank" rel="noopener">refresh</a> command reconciles the state file with <g class="gr_ gr_18 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar only-ins replaceWithoutSep" id="18" data-gr-id="18">real</g> state of your infrastructure. It modifies your state file but does not change any infrastructure. Any proposed change will take place during the next plan or apply. </li><li>TIP Terraform does come with <a href="https://www.terraform.io/docs/commands/state/index.html" target="_blank" rel="noopener">a command line tool for editing the state</a>. It’s called terraform state. You can list the contents of the current state using the terraform state list command. You can use the terraform state show command to show the state of a specific resource. You can move items in the state or to another state. You can also remove items from the state. </li><li>The lifecycle meta-parameter provides the ability to control the life cycle of a resource. It has several options you can configure:<ul><li>create_before_destroy — If a resource is going to be recreated, then the new resource is created before the old resource is deleted. This is useful for creating resources that replace others, such as creating a new DNS record before you delete an old one.</li><li>ignore_changes — Allows you to specify a list of attributes that will be<br/>ignored by Terraform. </li><li>prevent_destroy — Does not delete the resource, even if a plan requires it. Any plan or execution that proposes destroying this resource will exit with an error. </li></ul></li><li>TIP Your backend configuration cannot contain interpolated variables. This is because this configuration is initialized prior to Terraform parsing these variables. </li><li>NOTE Remember Terraform stores modules in the .terraform directory. Your local cache of the remote state file is also stored there. As we’ve discussed elsewhere, you’ll want to add this directory and the <g class="gr_ gr_358 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar multiReplace" id="358" data-gr-id="358">terraform</g><g class="gr_ gr_384 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Style replaceWithoutSep" id="384" data-gr-id="384">.<g class="gr_ gr_357 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="357" data-gr-id="357">tfstate</g></g> file to your .gitignore file to ensure neither <g class="gr_ gr_415 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar multiReplace" id="415" data-gr-id="415">are</g> committed to version control. </li><li>To use Terraform in a shared environment you’ll need to develop a workflow and process for collaborating. </li><li>TIP We can query more than one remote state by specifying the terraform_remote_state data source multiple times. Remember that each data source, like our resources, needs to be named uniquely. </li><li>NOTE For a data source to be read, the remote state needs to exist. If the configuration you’re fetching doesn’t exist—for example, if it’s been destroyed or not yet applied—then your remote state will be returned empty. Any variables you are populating will return an error. </li><li>NOTE Only the root-level outputs from the remote state are available.<br/>Outputs from modules within the state cannot be accessed. If you want a module output to be accessible via a remote state, you must expose the output in the top-level configuration. </li><li>Remote state best lends itself to provisioning use. There are variables or data you want to make use of when you build your stack. They’re often only used once or twice during that process. They don’t require you to regularly query that data source while your application or service is being run. Service discovery tends to be used at runtime and exercised regularly when applications and services run—for example,<br/>by querying the address of a required service. It generally requires a more resilient and faster service with a higher availability than our remote state. </li><li>TIP Rather than specify the access_token you could use the CONSUL_HTTP_TOKEN environment variable or specify it via the -backend-config command line flag. This keeps your token out of your local state.</li><li>There are some other tools available to help manage Terraform’s state:<ul><li><a href="https://github.com/opencredo/terrahelp" target="_blank">Terrahelp</a>: Go utility that provides Vault-based encryption and decryption of state files.</li><li><a href="https://github.com/gruntwork-io/terragrunt" target="_blank">Terragrunt</a>: Go tool for managing locking and state that can be used as glue in a multi-environment setup.</li><li><a href="https://github.com/nadnerb/terraform_exec" target="_blank">Terraform_exec</a>: Go wrapper that allows Terraform projects to have multiple environments synced to S3.<br/></li></ul></li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Chapter 6: Building a Multi-Environment Architecture</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>Terraform users will tell you that working out how to organize and lay out your code is crucial to having a usable Terraform environment.</li><li>We should ensure our code is clean, simple, and well documented. There are some good guidelines to work within to help with this:<ul><li>All code should be in version control.<br/></li><li>Always comment code when it requires explanation.<br/></li><li>Add description fields to all variables.<br/></li><li>Include README files or documentation for your module and their interfaces.<br/></li><li>Running terraform <g class="gr_ gr_22 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling" id="22" data-gr-id="22">fmt</g> and terraform validate prior to committing or as a commit hook is strongly recommended to ensure your code is well formatted and valid.</li></ul></li><li>Before you apply your configuration in your production environment, apply it in your development environment. Apply it using plan output files in iterative pieces to confirm it is working correctly. </li><li>You should have your code in version control so it becomes easy to pass changes through an appropriate workflow. Many people use the GitHub Flow to review and promote code. Broadly, this entails:<ul><li>Creating a branch.</li><li>Developing your changes.</li><li>Creating a pull request with your changes.</li><li>Reviewing your code changes.</li><li>Merging your changes to master and deploying them.</li></ul></li><li>The path variable can be suffixed with a variety of methods to select specific paths. For example:<br/><ul><li>path.cwd for <g class="gr_ gr_199 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar only-ins doubleReplace replaceWithoutSep" id="199" data-gr-id="199">current</g> working directory.<br/></li><li>path.root for the root directory of the root module.</li><li>path.module for the root directory of the current module.</li></ul></li><li>NOTE The Terraform interpolation documentation explains the path variable in more detail. </li><li>Another useful feature when thinking about workflow <g class="gr_ gr_269 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar multiReplace" id="269" data-gr-id="269">are</g> Terraform state environments. State environments were introduced in Terraform 0.9. You can think about a state environment as branching version control for your Terraform resources. </li><li>A state environment is a namespace, much like a version control branch. They allow a single folder of Terraform configuration to manage multiple states of resources. They are useful for isolating a set of resources to test changes during development. Unlike version control though, state environments do not allow merging, any changes you make in a state environment need to be re-applied to any other environments. </li><li>There are also some tools, blog posts, and resources designed to help run Terraform in a multi-environment setup.<br/><ul><li><a href="https://github.com/kkwoker/terrenv" target="_blank">Terrenv</a> — RubyGem for setting up Terraform environments.<br/></li><li><a href="https://github.com/gruntwork-io/terragrunt" target="_blank">Terragrunt</a> — Go tool for managing locking and state that can be used as glue in a multi-environment setup.</li><li><a href="https://charity.wtf/2016/03/30/terraform-vpc-and-why-you-want-a-tfstate-file-per-env/" target="_blank">Terraform, VPC, and why you want a Tfstate file per env</a> — Great post by Charity Majors on running Terraform in multiple environments.</li><li><a href="http://www.antonbabenko.com/2016/09/21/how-i-structure-terraform-configurations.html" target="_blank">How I structure Terraform configurations</a> — Useful post from Anton<br/>Babenko on structuring Terraform code and environments.<br/></li><li><a href="https://www.youtube.com/watch?v=RldRDryLiXs" target="_blank">Terraform at Scale</a> — Video from Calvin French-Owen (Co-founder and CTO at Segment) talking about running Terraform at scale.</li></ul></li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Chapter 7: Infrastructure Testing</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>You can also decorate control blocks with metadata<g class="gr_ gr_488 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Style replaceWithoutSep" id="488" data-gr-id="488">.Software</g> tests validate that your software does what it is supposed to do. Loosely, they’re a combination of quality measures and correctness measures. We’re going to apply some of the principles of software testing to our infrastructure. </li><li>A Terraform resource is a unit of isolated code about which we can reason and write tests to ensure the combination of the inputs and execution result in the correct outputs. With Terraform this is made<br/>even easier by the declarative nature of resources. </li><li>Sadly, testing on Terraform is still in the early stages and has limitations. At the moment there are a limited set of testing frameworks and harnesses that support Terraform. We’re going to see what we can achieve now by looking at a tool called Test Kitchen. </li><li><a href="https://kitchen.ci/">Test Kitchen</a> is a test harness to execute infrastructure and configuration management code on isolated platforms. It builds your infrastructure, configuration, or environment, and then validates it against a series of tests. </li><li>We’re going to use <a href="https://www.inspec.io/" target="_blank" rel="noopener">InSpec</a> with Test Kitchen to test our Terraform-built infrastructure. InSpec is an infrastructure-testing framework built around the concept of compliance controls. You write a series of “controls”—compliance statements backed with individual tests. </li><li>Test Kitchen works by creating the infrastructure we want to test, connecting to it, and running a series of tests to validate the right infrastructure has been built. </li><li>Test Kitchen stores all of its information about <g class="gr_ gr_204 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar only-ins doubleReplace replaceWithoutSep" id="204" data-gr-id="204">state</g> in a special directory called .kitchen at the root of our environment. Test Kitchen also uses a special YAML configuration file, .kitchen.yml, that tells Test Kitchen how and what to test. </li><li>NOTE You’ll need to ensure the host running Test Kitchen can connect via SSH to the hosts upon which you wish to run tests. </li><li>You can populate the inspec.yml file with a variety of metadata to identify the suite of tests. The name setting is the only required setting, but other settings help to describe the purpose of your suite.</li><li>We can test whether the resulting suite of tests is valid is using the <g class="gr_ gr_263 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="263" data-gr-id="263">inspec</g> binary. </li><li>Test Kitchen’s <a href="https://www.inspec.io/docs/reference/dsl_inspec/" target="_blank" rel="noopener">InSpec controls are expressed in a Ruby DSL</a> (Domain Specific Language) that will be familiar to anyone who has used <a href="http://rspec.info/" target="_blank" rel="noopener">RSpec</a>, as it’s built on top of it. </li><li>The control block wraps a collection of controls. The describe block wraps individual controls. The <g class="gr_ gr_365 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar multiReplace" id="365" data-gr-id="365">describe</g> block must contain at least one control. A control block must contain at least one describe block, but may contain as many as needed. </li><li>Each control is made up of resources and <g class="gr_ gr_406 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="406" data-gr-id="406">matchers</g> that are combined into tests. Resources are components that execute checks of some kind for a test: run a command, check a configuration setting, check the state of a service, and so on.</li><li><g class="gr_ gr_426 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="426" data-gr-id="426">InSpec</g> has a long list of <a href="https://www.inspec.io/docs/reference/resources/" target="_blank" rel="noopener">built-in resources</a> and has the ability for you to <a href="https://www.inspec.io/docs/reference/dsl_resource/" target="_blank" rel="noopener">write your own custom resources</a>. Matchers are <a href="https://www.inspec.io/docs/reference/matchers/" target="_blank" rel="noopener">a series of methods</a> that check, by various logic, if <g class="gr_ gr_463 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar only-ins doubleReplace replaceWithoutSep" id="463" data-gr-id="463">output</g> from a resource matches the output you expect. So a matcher might test equality, presence, or a regular expression.</li><li>You can also decorate control blocks with metadata. This adds metadata to the test to help folks understand what the test does and,<br/>importantly, why the test failing matters. In this <g class="gr_ gr_504 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Punctuation only-ins replaceWithoutSep" id="504" data-gr-id="504">example</g> we’ve decorated our control with a title and a description—a plain-English explanation of what it is and how it works. We’ve also added a couple of tags to the control. </li><li>The kitchen test command runs all the steps in our workflow: create, converge, and verify. We’re also going to pass in a command line flag: --destroy passing. The --destroy flag potentially destroys the instance after our tests run. The passing option constrains it to only destroy the infrastructure if all the tests pass. An alternative is the --destroy always <g class="gr_ gr_551 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar only-ins doubleReplace replaceWithoutSep" id="551" data-gr-id="551">flag</g>, which always destroys the instance.</li><li>TIP There’s a useful, detailed Test Kitchen example including fixtures and more complex configuration in the kitchen-terraform GitHub repository. </li><li>As it’s the early days for Terraform, there aren’t a lot of alternatives for testing. The current Test Kitchen solution requires direct SSH access to connect, which is an unfortunate limitation.</li><li>There is, however, an alternative using another framework called <a href="https://serverspec.org/" target="_blank">ServerSpec</a>. <a href="https://twitter.com/lusis" target="_blank">John Vincent</a> has provided <a href="https://gist.github.com/lusis/9c0fd50e0de51c3d80b2" target="_blank">a Gist showing how you might integrate ServerSpec with Terraform</a>.<br/></li></ul>
<!-- /wp:list -->
