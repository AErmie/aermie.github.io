---
layout: page
title: Book Review: The Packer Book
date: 2018-08-09 18:38
author: AdinErmie
comments: true
categories: []
---
<!-- wp:image {"id":31431,"align":"left"} -->
<figure class="wp-block-image alignleft"><img src="/wp-content/uploads/2018/08/ThePackerBook_Cover-188x300.jpg" alt="" class="wp-image-31431"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Recently, I finished reading <a href="https://packerbook.com/" target="_blank" rel="noreferrer noopener">The Packer Book</a> by James Turnbull.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When I started reading this book, I had no experience with Packer (but a high-level understanding of its use case). And so, I was looking for a book that would provide a good foundation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I particularly found chapter 3 <strong>("First Steps with Packer”)</strong> chapter 4 <strong>("Provisioning with Packer")</strong>, chapter 6 <strong>("Testing Packer")</strong>, and chapter 7 <strong>("Pipelines and Workflows")</strong>, of most value, because it built on what little I already knew, and expanded on this through demonstration of testing images, and integration into pipelines (which is a key component of <g class="gr_ gr_285 gr-alert sel gr_spell gr_replaced gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="285" data-gr-id="285">DevOps</g>).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The only thing I wish this book (or similar resources like it) had, was examples specific to Microsoft Azure (since that's the environment I'm working in). Most DevOps tooling tutorials, books, videos, courses, etc. all seem to focus on Amazon Web Services (AWS).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I’ve decided to share my highlights from reading this specific publication, in case the points that I found of note/interest will be of some benefit to someone else. So, here are my highlights (by chapter). Note that not every chapter will have highlights (depending on the content and the main focus of my work).</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Chapter 1: Introduction to Packer</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>Packer is a free and open-source image-building tool, written in Go and licensed under the Mozilla Public License 2.0. It allows you to create identical machine images, potentially for multiple target platforms, from a single configuration source. Packer supports Linux, Microsoft Windows, and Mac OS X, as well as other operating systems, and has support for a wide variety of image formats, deployment targets, and integrations with other tools. </li><li>Packer allows you to create pipelines for building and deploying images, which in turn allows you to produce consistent, repeatable images.</li><li>Packer is also portable. As it has a central-configuration construct—an image template—it allows you to standardize images across multiple target platforms. You can build images across cloud platforms—like Amazon and Google—that are consistent with images built on internal platforms like VMware or OpenStack, container environments like Docker and Kubernetes, and even individual development environments located on developer laptops. </li><li>Packer allows you to bake an appropriate and testable portion of your configuration into images without the overhead and complexity of previous image-building solutions. </li><li>You can also ensure that consistent configuration for things like patching, time, networking, security, and compliance are maintained across environments. For example, an infrastructure or a security team can use Packer to build images that are then shared with other groups to provide baseline builds that force cross-organizational standards.<br/></li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Chapter 2: Installing Packer</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>TIP On some Red Hat and Fedora-based Linux distributions there is another tool named packer installed by default. You can check for this using which -a packer. If you find this tool already present you should rename the new packer binary to an alternate name, such as packer.io. </li><li>NOTE Packer requires Go 1.6 or later.</li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Chapter 3: First Steps With Packer</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>Packer calls the process of creating an image a <em>build</em>. <em>Artifacts</em> are the output from builds. One of the more useful aspects of Packer is that you can run multiple builds to produce multiple artifacts. </li><li>A <em>build</em> is fed from a <em>template</em>. The template is a JSON document that describes the image we want to build—both where we want to build it and what the build needs to contain. </li><li>To determine what sort of image to build, Packer uses components called <em>builders</em>. A builder produces an image of a specific format—for example, an AMI builder or a Docker image builder.</li><li>User variables are useful in these three ways:<ul><li>As shortcuts to values that you wish to use multiple times.<br/></li><li>As variables with a default value that can be overridden at build time.<br/></li><li>For keeping secrets or other values out of your templates.<br/></li></ul></li><li>User variables must be defined in the variables block. If you have no variables then you simply do not specify that block.</li><li>If a variable is null then, for a template to be valid and executed, its value must be provided in some way when Packer runs. </li><li>TIP You can find a <a href="https://www.packer.io/docs/templates/engine.html" target="_blank" rel="noopener">full list of the available functions</a> in the Packer engine documentation.</li><li>NOTE You can only use environment variables inside the variables block. This is to ensure a clean source of input for a Packer <g class="gr_ gr_268 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar multiReplace" id="268" data-gr-id="268">build</g>. </li><li>If you attempt to define the same variable more than once, the last definition of the variable will stand. </li><li>Specify the builder you want to use using the type field, and note that each build in Packer has to have a name. In most <g class="gr_ gr_352 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Punctuation only-ins replaceWithoutSep" id="352" data-gr-id="352">cases</g> this defaults to the name of the builder</li><li>However, if you need to specify multiple builders of the same type—such as if you’re building two AMIs—then you need to name your builders using a name key. </li><li>NOTE If you specify two builders of the same type, you must name at least one of them. Builder names need to be unique.</li><li>Our AMI name uses two functions: timestamp and clean_ami_name. The timestamp function returns the current Unix timestamp. We then feed it into the clean_ami_name function, which removes any characters that are not supported in an AMI name. </li><li>NOTE There’s also a <g class="gr_ gr_474 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="474" data-gr-id="474">uuid</g> function that can produce a UUID if you want a more granular name resolution than time in seconds.</li><li>Packer builders communicate with the remote hosts they use to build images with a series of connection frameworks called <a href="https://www.packer.io/docs/templates/communicator.html" target="_blank" rel="noopener">communicators</a>. You can consider communicators as the “transport” layer for Packer. Currently, Packer supports SSH (the default), and WinRM (for Microsoft Windows), as communicators. </li><li>Packer comes with a useful validation sub-command to help us with this. It performs syntax checking and validates that the template is complete. </li><li>TIP You can use the packer inspect command to interrogate a template and see what it does. </li><li>TIP You can also output logs in machine-readable form by adding the<br/>-machine-readable flag to the build process. You can find the <a href="https://www.packer.io/docs/commands/index.html#format-for-machine-readable-output" target="_blank" rel="noopener">machine-readable output’s format</a> in the Packer documentation.</li><li>NOTE If the build were for some other image type—for example, a virtual machine—then Packer might emit a file or set of files as artifacts from the build. <br/></li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Chapter 4: Provisioning With Packer</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>Provisioners execute actions on the image being built. These actions, depending on the provisioner, can run scripts or system commands, and execute third-party tools like configuration management.</li><li>You can use one or more types of provisioners during a build—for example, you could use one provisioner to configure and install the requirements for another provisioner.</li><li>Provisioners are defined in their own JSON array, provisioners, inside your Packer template.</li><li>Each provisioner is defined as an element in the <g class="gr_ gr_102 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar multiReplace" id="102" data-gr-id="102">provisioners</g> array. Every provisioner has one required key: type, the type of provisioner.</li><li>The <a href="https://www.packer.io/docs/provisioners/shell.html" target="_blank" rel="noopener">shell provisioner</a> executes scripts and commands on the remote image being built. It connects to the remote image via SSH and executes any commands using a shell on that remote host.</li><li>The shell provisioner can execute a single command, a series of commands, a script, or a series of scripts.</li><li>TIP There’s also two flags, -debug flag which provides more information and interaction when building complex templates, and -on-error, which <a href="https://www.packer.io/docs/commands/build.html#on-error-cleanup" target="_blank" rel="noopener">tells Packer what to do when something goes wrong</a>. The -debug flag also disables parallelization and is more verbose. The Packer documentation has <a href="https://www.packer.io/docs/other/debugging.html" target="_blank" rel="noopener">some more general debug</a> tips.</li><li>NOTE The shell provisioner has a cousin called <a href="https://www.packer.io/docs/provisioners/shell-local.html" target="_blank" rel="noopener">shell-local</a> that runs commands locally on the host running Packer.</li><li>TIP The inline commands are executed with a <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)" target="_blank" rel="noopener">shebang</a> of /bin/sh -e. You can adjust this using the <a href="https://www.packer.io/docs/provisioners/shell.html#inline_shebang" target="_blank" rel="noopener">inline_shebang key</a>.</li><li>In addition to a command or series of <g class="gr_ gr_204 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Punctuation only-ins replaceWithoutSep" id="204" data-gr-id="204">commands</g> you can <a href="https://www.packer.io/docs/provisioners/shell.html#script" target="_blank" rel="noopener">run a script</a> using the script key. The script key is the path to a script to be executed. </li><li>The location of the script can be absolute or relative, depending on how it is specified. If it is specified relative, then it is relative to the location of the template file. </li><li>NOTE The -x flag on the shebang is useful as it <g class="gr_ gr_281 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="281" data-gr-id="281">echo’es</g> the commands<br/>executed, allowing you to see what’s happening when your script is run.</li><li>By default, it’ll execute the command by <g class="gr_ gr_301 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling" id="301" data-gr-id="301">chmod’ing</g> it into an executable form and running it. This means the script you write needs to have a shebang, then can be executed by being directly called.</li><li>TIP You can modify the method by which Packer executes scripts by changing the <a href="https://www.packer.io/docs/provisioners/shell.html#execute_command" target="_blank" rel="noopener">execute_command</a> key, for example instead of making the script executable you could call it with another binary.</li><li>The last execution method for the shell provisioner is to execute a series of scripts, expressed as an array in <g class="gr_ gr_382 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar multiReplace" id="382" data-gr-id="382">the scripts key</g>. The scripts will be executed in the sequence in which they are defined.</li><li>Packer provides a provisioner that allows us to provision files, like content or configuration files, into our host.</li><li>TIP If your provisioning process requires a reboot or restart, you can <a href="https://www.packer.io/docs/provisioners/shell.html#handling-reboots" target="_blank" rel="noopener">configure Packer to handle delays, failures, and retries</a>.</li><li>The file <a href="https://www.packer.io/docs/provisioners/file.html" target="_blank" rel="noopener">provisioner</a> uploads files, via Packer’s communicators, by default SSH from our local host to the remote host. The file provisioner is usually used in conjunction with the shell provisioner: the file provisioner uploads a file then the shell provisioner manipulates the uploaded file. (This two-step process primarily caters for file permission issues—Packer typically only has permission to upload files to locations it can write to, such as /<g class="gr_ gr_461 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling" id="461" data-gr-id="461">tmp</g>.) We can then execute the shell provisioner with escalated privileges—for example, by prefixing it with the <g class="gr_ gr_463 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling" id="463" data-gr-id="463">sudo</g> command.</li><li>The file provisioner specifies a source and destination for the file. The source is defined absolutely or relative to the template.</li><li>The destination is on the remote host and Packer must be able to write to it. Packer also can’t create any parent directories—you’ll either need to create those with a shell provisioner command or script prior to the <g class="gr_ gr_657 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Punctuation only-del replaceWithoutSep" id="657" data-gr-id="657">upload,</g> or upload to an existing directory. </li><li>In addition to uploading single files, we can also use the file provisioner to upload whole directories. Like with single file provisioning, the destination directory must exist. And upload behavior is much like <g class="gr_ gr_671 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling" id="671" data-gr-id="671">rsync</g>: the existence of a trailing slash determines the behavior of the upload.</li><li>If neither the source nor the destination <g class="gr_ gr_729 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar multiReplace" id="729" data-gr-id="729">have</g> a trailing slash then the local directory will be uploaded into the remote <g class="gr_ gr_767 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del" id="767" data-gr-id="767">director</g>.</li><li>If the source has a trailing slash and the destination does not, then the contents of the directory will be uploaded directly into the destination.</li><li>TIP You can also upload symbolic links with Packer but most provisioners will <a href="https://www.packer.io/docs/provisioners/file.html#symbolic-link-uploads" target="_blank" rel="noopener">treat them as regular files</a>. </li><li>TIP If there isn’t a provisioner that meets your needs, you can add your own via a custom provisioner plugin. </li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Chapter 5: Docker and Packer</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>To build Docker images, Packer uses the Docker daemon to run containers, runs provisioners on those containers, <g class="gr_ gr_3 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del" id="3" data-gr-id="3">then</g> can commit Docker images locally or push them up to the Docker Hub. </li><li>When building Docker images, Packer and the Docker builder need to run on a host that has Docker installed. </li><li>The type of builder we’ve specified is docker. We’ve specified a base image for the builder to work from; this is much like using the FROM instruction in a Dockerfile, using the image key.</li><li>The type, as always, and the image are required keys for the Docker builder. You must also specify what to do with the container that the Docker builder builds. </li><li>The Docker builder has three possible output actions. You must specify one:<ul><li>Export - Export an image from the container as a <g class="gr_ gr_38 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del" id="38" data-gr-id="38">tar ball</g>, as above with the export_path key.<br/></li><li>Discard - Throw away the container after the build, using the discard key. </li><li>Commit - Commit the container as an image available to the Docker daemon that built it, using the commit key.</li></ul></li><li>Sometimes a provisioner isn’t quite sufficient and you need to take some additional actions to make a container fully functional. The docker builder comes with a key called changes that allows you to specify some Dockerfile instructions.</li><li>NOTE The changes key behaves in much the same way as the docker commit --change command line option. </li><li>You can’t change all Dockerfile instructions, but you can change the CMD, ENTRYPOINT, ENV, EXPOSE, MAINTAINER, USER, VOLUME, and WORKDIR instructions. </li><li>Post-processors take actions on the artifacts, usually images, created by Packer. They allow us to store, distribute, or otherwise process those artifacts. </li><li>For each post-processor definition, Packer will take the result of each of the defined builders and send it through the post-processors. This means that if you have one post-processor defined and two builders defined in a template, the postprocessor will run twice (once for each builder), by default.<br/></li><li>There are three ways to define post-processors: simple, detailed, and in sequence. A simple post-processor definition is just the name of a post-processor listed in an array. </li><li>A simple definition assumes you don’t need to specify any configuration for the post-processor. A more detailed definition is much like a builder definition and allows you to configure the post-processor. </li><li>The last type of post-processor definition is a sequence. This is the most powerful use of post-processors, chained in sequence to perform multiple actions. It can contain simple and detailed post-processor definitions, listed in the order in which you wish to execute them. </li><li>Any artifacts a post-processor generates is fed into the next post-processor in the sequence.</li><li>NOTE You can only nest one layer of <g class="gr_ gr_389 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar only-ins doubleReplace replaceWithoutSep" id="389" data-gr-id="389">sequence</g>. </li><li>TIP You can tag and send an image to multiple repositories by specifying the docker-tag and docker-push post-processors multiple times. </li><li>There are also other post-processors that might interest you. You can find a full list in the Packer documentation.<br/></li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Chapter 6: Testing Packer</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>TIP Serverspec also supports running tests remotely. We could make use of the shell-local provisioner to run Serverspec in its SSH mode, which connects via SSH and executes the tests. This would save us uploading and <g class="gr_ gr_19 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar multiReplace" id="19" data-gr-id="19">installing</g> anything on the image. This blog post discusses running Packer and Serverspec in this mode. Or you can see an example of the configuration in this chapter adapted for SSH in this Gist.</li><li>NOTE If we wanted to tidy up after running our tests we could also uninstall the <g class="gr_ gr_10 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="10" data-gr-id="10">serverspec</g> gem. </li><li>TIP There are alternatives to Serverspec, like InSpec, Goss, or TestInfra that might also meet your testing needs. </li><li>Serverspec uses the same DSL as RSpec. To write tests we define a set of expectations inside a specific context or related collection of tests, usually in an individual file for each item we’re testing.  </li><li>TIP There’s also the useful <g class="gr_ gr_103 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="103" data-gr-id="103">serverspec</g>-init command which initializes a set of new tests. </li><li>We’re requiring a spec_helper. This helper loads useful configuration for each test and is contained in the spec directory in the spec_helper.<g class="gr_ gr_133 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="133" data-gr-id="133">rb</g> file. Let’s see it now.  </li><li>Serverspec has two modes of operation—the one we’re using now, exec, runs all tests locally—and an SSH mode, which, as we mentioned earlier, allows us to run the tests remotely. <br/></li><li>We generally want to set a context for our tests; this groups all of the relevant tests together. To do this we <g class="gr_ gr_260 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar only-ins replaceWithoutSep" id="260" data-gr-id="260">use</g> describe block. </li><li>Each assertion is wrapped in <g class="gr_ gr_272 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar only-del replaceWithoutSep" id="272" data-gr-id="272">an it</g> … end block. Inside that <g class="gr_ gr_273 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Punctuation only-ins replaceWithoutSep" id="273" data-gr-id="273">block</g> we use the expect syntax to specify the details of our assertion. </li><li>NOTE Serverspec automatically detects the operating system of the host on which it is being run. This allows it to know what service management tools, package management tools, or the like need to be queried to satisfy a resource. For example, on Ubuntu, Serverspec knows to use APT to query a package’s state. </li><li>TIP Check out Better Specs for some tips and tricks for writing better RSpec tests.</li><li>TIP You can find the full list of available resources in the Serverspec documentation. </li><li>Our <g class="gr_ gr_139 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="139" data-gr-id="139">Rakefile</g> requires rake and the <g class="gr_ gr_140 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="140" data-gr-id="140">rspec</g> Rake tasks and then creates a new Rake task. That task executes any files ending in _spec in the spec directory as RSpec tests. It also ensures that if any of the tests fail that it’ll return a non-zero exit code. </li><li>TIP When testing like this, it’s useful to run Packer with the -debug flag enabled, which stops between steps and allows you to debug the server if any issues emerge.<br/></li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Chapter 7: Pipelines and Workflows</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>An override allows you to specify a varying action on a specific build. Each override takes the name of a builder, in our case amazon-<g class="gr_ gr_4 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="4" data-gr-id="4">ebs</g>, and specifies one or more keys that are different for that provisioner when it is executed for that build. </li><li>NOTE The execute_command key also has access to the Vars variable, which contains all of the available environmental variables. </li><li>The only key <g class="gr_ gr_52 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del" id="52" data-gr-id="52">constrains</g> a post-processor to only run when specific builders are invoked. We can specify an array of builder names—in our <g class="gr_ gr_81 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Punctuation only-ins replaceWithoutSep" id="81" data-gr-id="81">case</g> this is the docker builder—for which these post-processors will be executed. This prevents the amazon-web builder from unnecessarily triggering the post-processors for Docker images.<br/></li><li>There’s also a second key, except, that performs a similar but reversed operation. If you use the <g class="gr_ gr_50 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del" id="50" data-gr-id="50">except</g> key, post-processors will run for all builders except those listed in that key. </li><li>If you ever need to only run one builder, there is another command line argument, -only, that you can pass to the packer build command.</li><li>NOTE <g class="gr_ gr_169 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar multiReplace" id="169" data-gr-id="169">There’s</g> a useful blog post and a tool called Bakery that <g class="gr_ gr_159 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar multiReplace" id="159" data-gr-id="159">show</g> some good CI/CD pipeline ideas. <br/></li></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>Chapter 8: Extending Packer</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>Packer plugins are standalone applications written in Go that Packer executes and communicates with. They aren’t meant to be run manually—the Packer core provides an integration API that has the communication layer between the core and plugins. </li><li>Packer’s plugins are Go applications. Their architecture is a little unusual. They are loaded at runtime as separate applications, and then IPC and RPC are used to communicate between the core and the various plugins. The core manages <g class="gr_ gr_73 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar multiReplace" id="73" data-gr-id="73">starting</g>, stopping, and cleaning up after each plugin execution.<br/></li><li>They’re linked via an interface with the core, but have their own dependencies and are isolated from the process space of the Packer core.</li><li>As Packer plugins are written in Go, it’s useful to get a good grounding in it. There are some resources available to help with that.<br/><ul><li>The <a href="https://tour.golang.org/welcome/1" target="_blank" rel="noopener">Golang tour</a>.<br/></li><li>The <a href="https://golang.org/doc/" target="_blank" rel="noopener">Golang learning resources</a>.<br/></li><li><a href="https://learnxinyminutes.com/docs/go/" target="_blank" rel="noopener">Learn Go in X Minutes</a>.<br/></li><li><a href="https://gobyexample.com/" target="_blank" rel="noopener">Go by example</a>.</li></ul></li><li>Each type of plugin has a defined interface. These take advantage of Go interfaces to define what is required to instantiate each type of plugin. To build a plugin we define the interface required for each type of plugin:<ul><li><a href="https://www.packer.io/docs/extending/custom-builders.html" target="_blank" rel="noopener">Builders</a><br/></li><li><a href="https://www.packer.io/docs/extending/custom-post-processors.html" target="_blank" rel="noopener">Post-processors</a><br/></li><li><a href="https://www.packer.io/docs/extending/custom-provisioners.html" target="_blank" rel="noopener">Provisioners</a></li></ul></li><li>TIP The best way to understand how plugins work is to look closely at the existing plugins in the Packer core and the documentation for the specific plugin types.<br/></li></ul>
<!-- /wp:list -->
